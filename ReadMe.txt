
Архитектура приложения и степень деления на слои зависят от целей. Этот параметр располагаются на шкале от полной 
изоляции всех слоёв друг от друга (но и высокой трудоёмкостью реализации), до компромиссной реализации 
(не такое полное разделение, зато меньше трудоёмкость).
Например разделять ли доменные сущности и сущности уровня хранилища, делать ли обобщённые репозитории или 
специализированные, выставлять ли из репозитория IQueryable. Всё это зависит от многих факторов и единственно 
правильного варианта, по моему мнению, нет.

В этом примере я исходил из задачи максимальной изоляции слоёв, как будто это заготовка для очень "большого"
приложения, которое пишется разными командами и т.п. Onion архитектура выбрана по этой же причине.

В примере присутствует "мутный" момент на счёт внедрения зависимостей, точнее корня сборки (Composition root). 
Я знаю что, по идеи, вся сборка должна производиться в одном месте и только эта assemble должна подключать IoC.
Но я не нашёл варианта как это реализовать со встроенным IoC, так чтобы сборка была вынесена из слоя представления.

Далее по плану, я должен был реализовать все функции сервисов приложения (ILampsComparisonService) и отобразить 
их на контроллеры WebApi (вкл. создание моделей уровня представления).
После этого добавить в контроллерах проверку входных данных через Fluent Validation.
Добавить аутентификацию через токены.
Создать миграции для EF.

Далее можно делать фронтэнд, взаимодействующий с WebApi.